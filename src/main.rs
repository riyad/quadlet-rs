mod systemd_unit;

use self::systemd_unit::{SystemdUnit, UNIT_GROUP};

use log::{debug, warn};
use std::collections::HashMap;
use std::env;
use std::fmt::Display;
use std::fs::{self, File};
use std::io::{self, BufWriter, Write};
use std::path::{Path, PathBuf};

#[macro_use]
extern crate lazy_static;
extern crate env_logger;

lazy_static! {
    static ref RUN_AS_USER: bool = std::env::args().nth(0).unwrap().contains("user");
    static ref UNIT_DIRS: Vec<PathBuf> = {
        let mut unit_dirs: Vec<PathBuf> = vec![];

        if let Ok(unit_dirs_env) = std::env::var("QUADLET_UNIT_DIRS") {
            let mut pathes_from_env: Vec<PathBuf> = unit_dirs_env
                .split(":")
                .map(|s| PathBuf::from(s))
                .collect();
            unit_dirs.append(pathes_from_env.as_mut());
        } else {
            if *RUN_AS_USER {
                unit_dirs.push(get_user_config_dir().join("containers/systemd"))
            } else {
                unit_dirs.push(PathBuf::from(QUADLET_ADMIN_UNIT_SEARCH_PATH));
                unit_dirs.push(PathBuf::from(QUADLET_DISTRO_UNIT_SEARCH_PATH));
            }
        }

        unit_dirs
    };
}

const QUADLET_VERSION: &str = "0.1.0";
const QUADLET_ADMIN_UNIT_SEARCH_PATH: &str  = "/etc/containers/systemd";
const QUADLET_DISTRO_UNIT_SEARCH_PATH: &str  = "/usr/share/containers/systemd";

const CONTAINER_GROUP: &str = "Container";
const X_CONTAINER_GROUP: &str = "X-Container";
const VOLUME_GROUP: &str = "Volume";
const X_VOLUME_GROUP: &str = "X-Volume";

struct ArgError(String);

#[derive(Debug)]
struct Config {
    output_path: PathBuf,
    verbose: bool,
    version: bool,
}

struct ConversionError<'a>(&'a str);

impl<'a> Display for ConversionError<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

fn help() {
    println!("Usage:
quadlet [-v|-verbose] [--version] OUTPUTDIR");
}


fn parse_args(args: Vec<String>) -> Result<Config, ArgError> {
    if args.len() < 2 {
        return Err(ArgError("Missing output directory argument".into()));
    }

    let mut cfg = Config {
        output_path: PathBuf::new(),
        verbose: false,
        version: false,
    };

    for arg in &args[1..args.len()-1] {
        match &arg[..] {
            "--verbose" => cfg.verbose = true,
            "-v" => cfg.verbose = true,
            "--version" => cfg.version = true,
            _ => return Err(ArgError(format!("Unknown argument {arg}"))),
        }
    }

    cfg.output_path = args.last().unwrap().into();

    Ok(cfg)
}

fn get_user_config_dir() -> PathBuf {
    // FIXME: get user's proper XDG_CONFIG_PATH
    PathBuf::from("~/.config")
}

fn load_units_from_dir(source_path: &PathBuf, units: &mut HashMap<String, SystemdUnit>) -> io::Result<()> {
    for entry in source_path.read_dir()? {
        let entry = entry?;
        let name = entry.file_name();

        if !name.to_string_lossy().ends_with(".container") && !name.to_string_lossy().ends_with(".volume") {
            continue;
        }

        if units.contains_key(name.to_string_lossy().as_ref()) {
            continue;
        }

        let path = entry.path();

        // FIXME: make debug!()
        println!("Loading source unit file {path:?}");

        let data = match fs::read_to_string(&*name) {
            Ok(data) => data,
            Err(e) => {
                warn!("Error loading {path:?}, ignoring: {e}");
                continue;
            }
        };

        let unit = match SystemdUnit::from_string(&data) {
            Ok(unit) => unit,
            Err(e) => {
                warn!("Error loading {path:?}, ignoring: {e}");
                continue;
           },
        };

        units.insert(name.to_string_lossy().to_string(), unit);
    }

    Ok(())
}

fn quad_replace_extension(file: &PathBuf, new_extension: &str, extra_prefix: &str, extra_suffix: &str) -> PathBuf {
    let parent = file.parent().unwrap();
    let base_name = file.file_stem().unwrap().to_str().unwrap();

    parent.join(format!("{extra_prefix}{base_name}{extra_suffix}{new_extension}"))
}

fn convert_container(unit: &SystemdUnit) -> Result<SystemdUnit, ConversionError> {
    Ok(SystemdUnit::new())
}

fn convert_volume(unit: &SystemdUnit) -> Result<SystemdUnit, ConversionError> {
    Ok(SystemdUnit::new())
}

fn generate_service_file(output_path: &Path, service_name: &PathBuf, service: &SystemdUnit, orig_unit: &SystemdUnit) -> io::Result<()> {
    let orig_path = &orig_unit.path;
    let out_filename = output_path.join(service_name);

    let out_file = File::open(&out_filename)?;
    let mut writer = BufWriter::new(out_file);

    writer.write("# Automatically generated by quadlet-generator\n".as_bytes())?;

    if let Some(orig_path) = orig_path {
        service.add_entry(
            UNIT_GROUP,
            "SourcePath".into(),
            orig_path.to_str().unwrap().into(),
        );
    }

    debug!("writing {out_filename:?}");

    service.write_to(&mut writer)?;

    Ok(())
}

fn enable_service_file(output_path: &Path, service_name: &PathBuf, service: &SystemdUnit) -> io::Result<()> {
    Ok(())
}

fn main() {
    let args: Vec<String> = env::args().collect();

    let cfg = match parse_args(args) {
        Ok(cfg) => cfg,
        Err(ArgError(msg)) => {
            println!("Error: {}", msg);
            help();
            std::process::exit(1)
        },
    };

    let mut builder = env_logger::Builder::from_default_env();
    builder
        .target(env_logger::Target::Stdout)
        .filter_level(if cfg.verbose { log::LevelFilter::Debug } else { log::LevelFilter::Info });
    builder.init();

    if cfg.version {
        println!("quadlet {}", QUADLET_VERSION);
        std::process::exit(0);
    }

    debug!("Starting quadlet-generator, output to: {:?}", &cfg.output_path);

    let unit_search_dirs = &*UNIT_DIRS;

    let mut units: HashMap<String, SystemdUnit> = HashMap::default();
    for source_path in unit_search_dirs {
        if let Err(e) = load_units_from_dir(&source_path, &mut units) {
            warn!("Can't read {source_path:?}: {e}");
        }
    }

    for (name, unit) in units {
        let mut extra_suffix = "";

        let service = if name.ends_with(".container") {
            match convert_container(&unit) {
                Ok(service_unit) => service_unit,
                Err(e) => {
                    warn!("Error converting {name:?}, ignoring: {e}");
                    continue;
                },
            }
        } else if name.ends_with(".volume") {
            extra_suffix = "-volume";
            match convert_volume(&unit) {
                Ok(service_unit) => service_unit,
                Err(e) => {
                    warn!("Error converting {name:?}, ignoring: {e}");
                    continue;
                },
            }
        } else {
            debug!("Unsupported type {name:?}");
            continue;
        };

        let service_name = quad_replace_extension(
            &PathBuf::from(name),
            ".service",
            "",
            extra_suffix,
        );

        match generate_service_file(&cfg.output_path, &service_name, &service, &unit){
            Ok(_) => {},
            Err(e) => {
                warn!("Error writing {service_name:?}, ignoring: {e}")
            },
        };
        match enable_service_file(&cfg.output_path, &service_name, &service) {
            Ok(_) => {},
            Err(e) => {
                warn!("Failed to enable generated unit for {service_name:?}, ignoring: {e}")
            },
        }
    }
}
